# 第二期代码海报内容之设计原则

---

成都开发部第二期代码海报的主要内容主要以**设计原则**为主，主要包括通用的设计原则和面向对象的设计原则两部分内容。目的是为了帮助开发人员避开不良设计、写出优秀代码提供指导方针。

## 一、通用设计原则

### KISS —— 保持简约(Keep It Simple,Stupid)

所谓`KISS`原则，即：`Keep It Simple,Stupid`，指设计时要坚持简约的原则，避免不必要的复杂化，并且易于修改。

> Everything should be made as simple as possible, but not simpler. - Albert Einstein

保持简单但不能掩盖软件丰富的内涵。即**简约而不简单**！简约是对复杂的事物抽丝剥茧去除细枝末节显露主要逻辑的过程。就像小时候老师教写文章，要求尽可能用朴实的语言，言简意赅的写出来，但却又要避免语言过于贫乏。

### DRY —— 不要让自己重复(Don't Repeat Yourself)

所谓`DRY`原则，即：`Don't Repeat Yourself`，不要让自己重复。

重复代码是软件程序变烂的万恶之首。`DRY`并不是指你不能复制代码，而是你复制的代码不能包含重复的“信息”。复制的东西并不仅仅是复制了代码，而是由于你把同一个信息散播在了代码的各个部分导致了有很多相近的代码也散播在各个地方。

“重复代码”有很多变体：

- 魔法数字、魔法字符串等
- 相同或相似的代码块
- 相似的逻辑及操作

解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过**重构**的手段来消除重复。发现和解决重复并不困难，但困难的是立即行动去解决重复，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。

### MCMC —— 高内聚低耦合(Maximize Cohesion,Minimize Coupling)

所谓`Maximize Cohesion,Minimize Coupling`原则，即：高内聚低耦合。这是判断设计好坏的标准，主要是看模块内的内聚性是否高，模块间的耦合度是否低。

内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。

Java中实现高内聚低耦合的常用方式：

- 少使用全局变量。
- 遵循一个定义只在一个地方出现。
- - 尽量不用**硬编码**的方式写程序。
- 少使用类的继承，多用接口隐藏实现的细节。
- 最后当然就是避免直接操作或调用其它模块或类（内容耦合）。
- 类属性和方法的声明少用`public`，多用`private`关键字，
- 模块的功能化分尽可能的单一，功能单一的模块供其它模块调用的机会就少。
- 多用设计模式，比如采用`MVC`的设计模式就可以降低界面与业务逻辑的耦合度。

### YAGNI —— 适可而止(You Ain’t Gonna Need It)

所谓`YAGNI`原则，即：`You Ain’t Gonna Need It`，你不需要它，更好的翻译是适可而止。它是一种极限编程（XP）实践，表示程序员不应为目前还不需要的功能编写代码。经常你自以为有用的功能，而实际上都是用不到的。`YAGNI`的观点是你应该**为了眼前的需要做设计而不是未来**。

> 只在真正需要某些功能的时候才去实现它，而不是仅仅因为你预见到它将出现。- XP的联合创始人Ron Jeffries

遵循`YAGNI`实践有两个主要原因：

- 你节约了时间，因为你避免了编写最终证明不必要的代码。
- 你的代码质量更高了，因为你使代码不必为你的“推测”所污染，而这些“推测”最终可能或多或少有些错误，但此时这些错误已牢牢地依附在你的代码中了。

所以，只有当你真正需要的时候才去添加额外的功能，不需要就不要画蛇添足。同时对于没有被使用到的代码，都应该立即删除，从而保持系统的精简，如果将来需要时再去书写或恢复，而且那时侯写出的代码也绝对比你以前的代码更符合需求。

## 二、面向对象设计原则

### SRP —— 单一职责原则(Single Responsibility Principle)

所谓`SRP`原则，即：`Single Responsibility Principle`，单一职责原则。原始定义如下：

> There should never be more than one reason for a class to change.(只有一个引起类改变的原因)

在面向对象编程领域中，单一职责原则规定每个类都应该有一个单一的职责或者叫功能，并且该功能应该由这个类完全封装起来。所有它的（这个类的）服务都应该严密的和该功能平行（功能平行，意味着没有依赖）。一个类或者模块应该有且只有一个改变的原因。

单一职责的好处：

- 类的复杂性降低，实现什么职责都有清晰明确的定义
- 可读性提高，复杂性降低，可维护性提高
- 变更引起的风险降低

### LSP —— 里氏替换原则(Liskov Substitution principle)

所谓`LSP`原则，即：`Liskov Substitution principle`，里氏替换原则。原始定义如下：

> Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的对象）

更通俗的定义即为：**子类可以扩展父类的功能，但不能改变父类原有的功能**。里氏替换原则包含了一下4层含义：

- 子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了LSP原则。
- 子类可以有自己的个性。子类当然可以有自己的行为和外观了，也就是方法和属性。
- 覆盖或实现父类的方法时输入参数可以被放大。即子类可以重载父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。即以子类中方法的前置条件必须与超类中被覆盖的方法的前置条件相同或者更宽松。
- 覆盖或实现父类的方法时输出结果可以被缩小。

### ISP —— 接口隔离原则(Interface Segregation Principle)

所谓`ISP`原则，即：`Interface Segregation Principle`，接口隔离原则。原始定义如下：

> The dependency of one class to another one should depend on the smallest possible interface.(类间的依赖关系应建立在最小的接口上。)

即，**接口尽量细化，接口中的方法尽量少**。接口隔离原则与单一职责原则的审视角度是不同的，单一职责原则要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分；而接口隔离原则要求接口的方法尽量少。根据接口隔离原则拆分接口时，首先必须满足单一职责原则。

采用接口隔离原则对接口进行约束时，要注意以下几点：

- 接口尽量小，但是要适度。
- 为依赖接口的类定制服务，只暴露它需要被调用的方法，不需要的方法则隐藏起来。
- 提高内聚，减少对外交互。

运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。

### OCP —— 开闭原则(Open Closed Principle)

所谓`OCP`原则，即：`Open Closed Principle`，开闭原则。原始定义如下：

> software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.(对扩展开放，对修改关闭)

开闭原则（OCP）是面向对象设计中**可复用设计**的基石，是面向对象设计中最重要的原则之一，其它很多的设计原则都是实现开闭原则的一种手段。核心就是：**对扩展开放，对修改关闭**。

实现开闭原则的关键就在于“抽象”。把系统的所有可能的行为抽象成一个抽象底层，这个抽象底层规定出所有的具体实现必须提供的方法的特征。作为系统设计的抽象层，要预见所有可能的扩展，从而使得在任何扩展情况下，系统的抽象底层不需修改；同时，由于可以从抽象底层导出一个或多个新的具体实现，可以改变系统的行为，因此系统设计对扩展是开放的。在实际开发过程的设计开始阶段，就要罗列出来系统所有可能的行为，并把这些行为加入到抽象底层，根本就是不可能的，这么去做也是不经济的。因此我们应该现实的接受修改拥抱变化，使我们的代码可以对扩展开放，对修改关闭。

### DIP —— 依赖倒置原则(Dependency Inversion Principle)

所谓`DIP`原则，即：`Dependency Inversion Principle`，依赖倒置原则。原始定义如下：

> High-level modules should not depend on low-level modules. Both should depend on abstractions.(高层模块不应该依赖低层模块，两者都应该依赖其抽象)

面向过程的开发，上层调用下层，上层依赖于下层，当下层剧烈变动时上层也要跟着变动，这就会导致模块的复用性降低而且大大提高了开发的成本。面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。

依赖倒置原则主要有以下三层含义：

- 高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）；
- 抽象不应该依赖细节（具体实现）；
- 细节（具体实现）应该依赖抽象。

依赖倒置原则基于这样一个事实：**相对于细节的多变性，抽象的东西要稳定的多**。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在Java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。**依赖倒置原则的核心思想就是面向接口编程**。

### LOD —— 迪米特法则(Law of Demeter)

所谓`LOD`原则，即：`Law of Demeter`，迪米特法则，又叫作最少知识原则（`Least Knowledge Principle`，简写`LKP`），就是说一个对象应当对其他对象有尽可能少的了解。通俗的讲，一个类应该对自己需要耦合或调用的类知道得最少，被耦合的类是如何的复杂都和我没关系，即为“不和陌生人说话”。迪米特法则的英文解释如下：

> talk only to your immediate friends.(只与直接的朋友通信)

迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。

迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的“朋友类”来转达。因此，大量的应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度,同时也为系统的维护带来了难度。所以，在采用迪米特法则时需要反复权衡，不遵循不对，严格执行又会“过犹不及”。既要做到让结构清晰，又要做到高内聚低耦合。

### CARP —— 组合/聚合复用原则(Composition/Aggregation Reuse Principle)

所谓`CARP`原则，即：`Composition/Aggregation Reuse Principle`，组合复用原则。

组合复用原则的核心思想是：**尽量使用对象组合，而不是继承来达到复用的目的**。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。

继承的缺点主要有以下几点：

- 继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，虽然简单，但不安全，不能在程序的运行过程中随便改变。
- 基类的实现发生了改变，派生类的实现也不得不改变。
- 从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。

组合复用的缺点：就是用组合复用建造的系统会有较多的对象需要管理。

组合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合来实现复用；其次才考虑继承。在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。

使用继承时必须满足`Is-A`的关系是才能使用继承，而组合却是一种`Has-A`的关系。导致错误的使用继承而不是使用组合的一个重要原因可能就是错误的把`Has-A`当成了`Is-A`。

## 设计原则思维导图

### 文本格式

```markup
设计原则
    通用设计原则
        Keep It Simple,Stupid
        Don't Repeat Yourself
        Maximize Cohesion,Minimize Coupling
        You Ain’t Gonna Need It
    面向对象设计原则
        Single Responsibility Principle
        Liskov Substitution principle
        Interface Segregation Principle
        Open Closed Principle
        Dependency Inversion Principle
        Law of Demeter
        Composition/Aggregation Reuse Principle
```

### 图片格式

![设计原则](http://static.blinkfox.com/design_principle.png)