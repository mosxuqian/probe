# 近期代码复查问题整理

标签： Java 代码复查

---

以下中的代码是成都近一两月的代码复查问题整理。

## Java中嵌入CSS

```java
public void jqHtmlArea23f47_onShow(Item item) {
    item.set("text", isSSfj()?"拟定名称 <span style = 'color:red;font-size:12px;'>(请从以下拟定名称中，选择核准的律师事务所名称)</span>":"拟定名称");
}
```

上面的代码在`Artery`项目中会经常遇到。在`onShow`方法中嵌入了`CSS`样式，本质就是把一些不稳定、易变化的信息写死在了`Java`代码里，不便于维护和前端人员排查和修改样式。样式最好通过`class`类名写到`css`文件中，由前端代码来控制样式或者在Java后台代码中引用`class`类名。所以，如果要让Java开发人员来改的话，修改后的代码应该是这样子的：

```css
.fd-font {
    color:red;
    font-size:12px;
}
```

```java
public void jqHtmlArea23f47_onShow(Item item) {
    String label = isSSfj() ? "<span class='fd-font'>(请从以下拟定名称中，选择核准的律师事务所名称)</span>" : "";
    item.set("text", "拟定名称" + label);
}
```

## 重复代码

软件程序设计中，有一个`DRY`原则，即不要让自己重复。重复代码是软件程序变烂的万恶之首。`DRY`原则并不是指你不能复制代码，而是你复制的代码不能包含重复的**信息**。由于你把同一个信息散播在了代码的各个地方，在需求变更或者维护过程中，这个信息需要变更，那么各个包含这个信息的地方都必然会引起修改。所以为了减少开发人员修改代码的痛苦，大家要尽量遵循`DRY`原则。

重复代码有多种变体，如以下三种：

- 魔法数字、魔法字符串等
- 相同或相似的代码块
- 相似的逻辑控制及操作

对于消除重复的代码有**事不过三**法则。

- 第一次先写了一段代码。
- 第二次在另一个地方写了一段相同或相似的代码，你已经有消除和提取重复代码的冲动了。
- 再次在另一个地方写了同样的代码，你已忍无可忍，现在可以考虑提取和消除重复代码了。

我们看下面这段包含高Npath复杂度，且有众多重复逻辑操作的代码如何重构。

重构前的原始代码：

```java
private void processCaseStage(DataObject dataObject) throws DataFlowException {
    String caseStageValue = null;
    if (caseStageValue == null) {
        Object targetDate = MetaDataUtils.getMemberValue(TAjAjjbxx.D_PJSXRQ, dataObject);
        caseStageValue = targetDate == null ? null : SacwConst.AJJD_PJSX;
    }

    if (caseStageValue == null) {
        Object targetDate = MetaDataUtils.getMemberValue(TAjAjjbxx.D_FYLARQ, dataObject);
        caseStageValue = targetDate == null ? null : SacwConst.AJJD_FYLA;
    }

    if (caseStageValue == null) {
        Object targetDate = MetaDataUtils.getMemberValue(TAjAjjbxx.D_TQGSRQ, dataObject);
        caseStageValue = targetDate == null ? null : SacwConst.AJJD_TQGS;
    }

    if (caseStageValue == null) {
        Object targetDate = MetaDataUtils.getMemberValue(TAjAjjbxx.D_LASCKSRQ, dataObject);
        caseStageValue = targetDate == null ? null : SacwConst.AJJD_SCQSSL;
    }

    if (caseStageValue == null) {
        Object targetDate = MetaDataUtils.getMemberValue(TAjAjjbxx.D_YSSCQSRQ, dataObject);
        caseStageValue = targetDate == null ? null : SacwConst.AJJD_YSQS;
    }

    if (caseStageValue == null) {
        Object targetDate = MetaDataUtils.getMemberValue(TAjAjjbxx.D_LARQ, dataObject);
        caseStageValue = targetDate == null ? null : SacwConst.AJJD_LAZC;
    }

    if(caseStageValue != null){
        MetaDataUtils.putMemberValue(dataObject, TAjAjjbxx.EntityId, TAjAjjbxx.C_AJJZJD, caseStageValue);
        logger.info("---------------->处理案件所处阶段，案件所处阶段为：" + caseStageValue);
    }else{
        throw new DataParseException("立案侦查日期、移送起诉日期、审查起诉受理日期、提起公诉日期、法院立案日期、裁判生效日期 这六个日期至少需要存在一个日期");
    }

}
```

代码复查出来的问题主要是`6`处相似的代码，包括相同的逻辑判断和相似的逻辑操作，还有`sonar`检查出来的高的`Npath`复杂度。该方法每个代码块中的只有两个常量不相同，而其他几个一模一样。其初衷也是想做成一个`链式`的处理过程。只要`caseStageValue != null`就不再向后处理了。

既然是`链式`的处理过程，那么很多高手应该都想到了使用**责任链模式**来重构了。但是由于`if`代码块中各部分的逻辑处理极其相似，杀鸡焉用牛刀。所以，我这里就采用**表驱动**的方式来重构，重构后的代码如下：

调用处就使用一行代码即可：

```java
private void processCaseStage(DataObject dataObject) throws DataFlowException {
    String caseStageValue = StageValueManager.newInstance().getStageValue(dataObject);
    if(caseStageValue != null){
        MetaDataUtils.putMemberValue(dataObject, TAjAjjbxx.EntityId, TAjAjjbxx.C_AJJZJD, caseStageValue);
        logger.info("---------------->处理案件所处阶段，案件所处阶段为：" + caseStageValue);
    }else{
        throw new DataParseException("立案侦查日期、移送起诉日期、审查起诉受理日期、提起公诉日期、法院立案日期、裁判生效日期 这六个日期至少需要存在一个日期");
    }
}
```

重点是对6种情况做统一有序的标识管理和遍历：

```java
/**
 * StageValueManager.
 * @author blinkfox on 2017-06-22.
 */
public final class StageValueManager {

    /**
     * 初始化6个案件阶段情况的常量的有序map.
     */
    @SuppressWarnings("serial")
    private static final Map<String, String> ajjdMap = new LinkedHashMap<String, String>() {{
        put(TAjAjjbxx.D_PJSXRQ, SacwConst.AJJD_PJSX);
        put(TAjAjjbxx.D_FYLARQ, SacwConst.AJJD_FYLA);
        put(TAjAjjbxx.D_TQGSRQ, SacwConst.AJJD_TQGS);
        put(TAjAjjbxx.D_LASCKSRQ, SacwConst.AJJD_SCQSSL);
        put(TAjAjjbxx.D_YSSCQSRQ, SacwConst.AJJD_YSQS);
        put(TAjAjjbxx.D_LARQ, SacwConst.AJJD_LAZC);
    }};

    /**
     * 私有构造方法.
     */
    private StageValueManager() {
        super();
    }

    /**
     * 获取新实例.
     * @return StageValueManager实例
     */
    public static StageValueManager newInstance() {
        return new StageValueManager();
    }

    /**
     * 获取各种情况的stageValue.
     * @param dataObject dataObject
     * @return caseStageValue
     */
    public String getStageValue(DataObject dataObject) {
        String caseStageValue = null;
        for (Map.Entry<String, String> entry : ajjdMap.entrySet()) {
            caseStageValue = MetaDataUtils.getMemberValue(entry.getKey(), dataObject) == null ? null : entry.getValue();
            if (caseStageValue != null) {
                break;
            }
        }
        return caseStageValue;
    }

}
```

从上面的重构示例来看，**消除重复代码会让你的代码结构发生本质的变化**。

解决重复的最佳的方式是通过培养良好的编码习惯来避免重复，通过**重构**的手段来消除重复。发现和解决重复并不困难，通过提取抽象、提取方法等措施就能消除重复，但困难的是**立即行动去解决重复**，从而不断的磨砺和提升自己的编程技艺，不断将私人代码变成公共代码，这才是自我提升的过程。解决了重复，经过一段时间，你就发现对整个系统的理解程度，在不知不觉中提高了不少。