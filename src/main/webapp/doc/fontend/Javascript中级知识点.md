# Javascript中级知识点

## 作用域

作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有**全局作用域**和**局部作用域**两种。

### 全局作用域

在代码中任何地方都能访问到的对象拥有全局作用域。一般来说以下几种情形：

- 最外层函数和在最外层函数外面定义的变量拥有全局作用域。
- 所有未定义而直接赋值的变量自动声明为拥有全局作用域。
- 所有window对象的属性拥有全局作用域。如：`window.name`、`window.location`等。

> **注**：全局变量存在于程序的整个生命周期。没有块级作用域。

### 局部作用域

局部作用域一般只在固定的代码片段内可访问到，最常见的是在函数内部，所有在一些地方也会看到有人把这种作用域称为**函数作用域**。

### 作用域链

JavaScript里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供JavaScript引擎访问的内部属性。其中一个内部属性是`Scope`，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。

因为全局变量总是存在于**运行时上下文**作用域链的最末端。所以，在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：**如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用**。

`with`语句主要用来临时扩展作用域链，将语句中的对象添加到作用域的头部。

```javascript
person = {name: "yhb", age: 22, height:175, wife: {name: "lwy", age: 21}};
with (person.wife) {
    console.log(name);
}
```

with语句将`person.wife`添加到当前作用域链的头部，所以输出的就是：`lwy`；with语句结束后，作用域链恢复正常。

> 当代码运行到with语句时，运行期上下文的作用域链临时被改变了。一个新的可变对象被创建，它包含了参数指定的对象的所有属性。这个对象将被推入作用域链的头部，这意味着函数的所有局部变量现在处于第二个作用域链对象中，因此访问代价更高了。
> **注**：在程序中应避免使用with语句。

## 闭包

### 一个示例

如何从外部读取局部变量？

```javascript
function f1() {
    var n=999;
    function f2() {
        alert(n); // 999
    }
}
```

在上面的代码中，函数f2就被包括在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是Javascript语言特有的"链式作用域"结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，**父对象的所有变量，对子对象都是可见的，反之则不成立**。

既然f2可以读取f1中的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！

```javascript
function f1() {
    var n=999;
    function f2() {
        alert(n); // 999
    }
    return f2;
}
var result=f1();
result(); // 999
```

### 闭包解释

在上面的代码中，f2函数就是闭包。**闭包**（closure）定义非常抽象，很难看懂。我的理解是，**闭包就是能够读取其他函数内部变量的函数**。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。

闭包最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中，不会在调用结束后被垃圾回收机制（garbage collection）回收。

**注意**：

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
- 闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

### 立即执行函数表达式

有时你想模拟一个模拟块级作用域，例如你想将变量从全局作用域隔离。完成这个工作的模式叫做 IIFE(立即执行函数表达式(Immediately Invoked Function Expression))：

```javascript
(function () {  // 块开始
    var tmp = ...;  // 非全局变量
}());  // 块结束
```

## 内存机制

首先JavaScript中的变量分为**基本类型**和**引用类型**。

- 基本类型就是保存在栈内存中的简单数据段。基本类型有`Undefined`、`Null`、`Boolean`、`Number`和`String`。这些类型在内存中分别占有固定大小的空间，他们的值保存在**栈空间**，我们通过按值来访问的。
- 引用类型指的是那些保存在堆内存中的对象。引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。栈内存中存放的只是该对象的访问地址，在堆内存中为这个值分配空间。

### 为什么会有栈内存和堆内存之分？

与垃圾回收机制有关，为了使程序运行时占用的内存最小。

当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；

当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。

### 垃圾回收机制

Javascript具有自动垃圾回收机制(GC:Garbage Collecation)，也就是说，执行环境会负责管理代码执行过程中使用的内存。

JavaScript垃圾回收的机制很简单：**找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行**。

不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后在函数中使用这些变量，直至函数结束，而闭包中由于内部函数的原因，外部函数并不能算是结束。

#### 清除方式

- **标记清除**：垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
- **引用计数**：引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。