# Java异常

## 前言

### 为什么要使用异常

在我们的程序中，任何时候任何地方因为任何原因都有可能会出现异常，在没有异常机制的时候我们是这样处理的：通过函数的返回值来判断是否发生了异常（这个返回值通常是已经约定好了的），调用该函数的程序负责检查并且分析返回值。虽然可以解决异常问题，但是这样做存在几个缺陷：

- 容易混淆。如果约定返回值为 -1 时表示出现异常，那么当程序最后的计算结果真的为 -1 呢？
- 代码可读性差。将异常处理代码和程序代码混淆在一起将会降低代码的可读性。
- 由调用函数来分析异常，这要求程序员对库函数有很深的了解。

> 在面向对象编程中提供的异常处理机制是提供代码健壮的强有力的方式。使用异常机制它能够降低错误处理代码的复杂度，如果不使用异常，那么就必须检查特定的错误，并在程序中的许多地方去处理它，而如果使用异常，那就不必在方法调用处进行检查，因为异常机制将保证能够捕获这个错误，并且，只需在一个地方处理错误，即所谓的异常处理程序中。这种方式不仅节约代码，而且把“概述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。总之，与以前的错误处理方法相比，异常机制使代码的阅读、编写和调试工作更加井井有条。（摘自《Think in java 》）。

### 基本定义

> 异常情形是指阻止当前方法或者作用域继续执行的问题。——《Think in java》

总的来说异常处理机制就是当程序发生异常时，它强制终止程序运行，记录异常信息并将这些信息反馈给我们，由我们来确定是否处理异常。

## 异常体系

在Java中，所有的事件都能由类描述，Java中的异常就是由`java.lang`包下的异常类来描述的。Java定义了一个异常类的层次结构，其以`Throwable`（万物即可抛）开始，派生出了`Error`和`Exception`，而`Exception`又派生出了`CheckedException`和`RuntimeException`。如下图所示：

### Throwable

Throwable（可抛出）是异常类的最终父类，它有两个子类，`Error`与`Exception`。

Throwable 中常用方法有：

- `getCause()`：返回抛出异常的原因。如果 cause 不存在或未知，则返回`null`。
- `getMessage()`：返回异常的消息信息。
- `printStackTrace()`：对象的堆栈跟踪输出至错误输出流，作为字段`System.err`的值。
- `toString()`：返回此`throwable`的简短描述。

### Error

Error（错误）：表示程序无法处理的错误，一般与程序员的执行操作无关。理论上这些错误是不允许发生的，如果发生，也不应该试图通过程序去处理，所以 Error 不是`try-catch`的处理对象，而 JVM 一般的处理方式是终止发生错误的线程。Error 类常见子类有`VirtualMachineError`、`StackOverFlowError`、`OutOfMemoryError`等。

在Java运行时内存中，除程序计数器外的虚拟机栈、堆、方法区在请求的内存无法被满足时都会抛出`OutOfMemoryError`；而如果线程请求的栈深度超出虚拟机允许的深度时，就会抛出`StackOverFlowError`。

### Exception

Exception（异常）：出现原因取决于程序，所以程序也理应通过`try-catch`处理。Exception 异常分为两类：`CheckedException`和`RuntimeException`，即**检查异常**与**运行时异常**。

- 检查异常：编译器要求必须处理，否则不能通过编译，使用`try-catch`捕获或者`throws`抛出。常见的检查异常有`IOException`及其子类、`EOFExcption`(文件已结束异常)、`FileNotFoundException`（文件未找到异常）。
- 运行时异常（也叫非检查异常）：编译期不会检查，所以在程序中可不处理，但如果发生，会在运行时抛出。

## 异常处理

### 处理机制

在 Java 应用程序中，异常处理机制为：**抛出异常**、**捕捉异常**。

- **抛出异常**：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。
- **捕获异常**：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。

对于运行时异常、错误或可查异常，Java技术所要求的异常处理方式有所不同。

- 对于方法运行中可能出现的Error，当运行方法不欲捕捉时，Java允许该方法不做任何抛出声明。因为，大多数 Error 异常属于永远不能被允许发生的状况，也属于合理的应用程序不该捕捉的异常。
- 对于所有的检查异常，Java规定：**一个方法必须捕捉，或者声明抛出方法之外。也就是说，当一个方法选择不捕捉检查异常时，它必须声明将抛出异常**。
- 对于所有运行时异常，Java规定：**运行时异常将由Java运行时系统自动抛出，允许应用程序忽略运行时异常**。

能够捕捉异常的方法，需要提供相符类型的异常处理器。所捕捉的异常，可能是由于自身语句所引发并抛出的异常，也可能是由某个调用的方法或者Java运行时 系统等抛出的异常。也就是说，**一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，异常总是先被抛出，后被捕捉的**。

任何Java代码都可以通过 Java 的`throw`语句抛出异常。

从方法中抛出的任何异常都必须使用`throws`子句。

捕捉异常通过`try-catch`语句或者`try-catch-finally`语句实现。

> 总体来说，Java规定：对于检查异常必须捕捉、或者声明抛出。允许忽略非检查的`RuntimeException`和`Error`。

### 处理方式

`try-catch`语句还可以包括第三部分，就是`finally`子句。它表示无论是否出现异常，都应当执行的内容。`try-catch-finally`语句的一般语法形式为：

```java
try {
    // 可能会发生异常的程序代码
} catch (Exception1 e1) {
    // 捕获并处理try抛出的异常类型Type1
} catch (Exception2 e2) {
    // 捕获并处理try抛出的异常类型Type2
} finally {
    // 无论是否发生异常，都将执行的语句块
}
```

- `try`块：用于捕获异常。其后可接零个或多个`catch`块，如果没有`catch`块，则必须跟一个`finally`块。
- `catch`块：用于处理`try`捕获到的异常。
- `finally`块：无论是否捕获或处理异常，`finally`块里的语句都会被执行。当在`try`块或`catch`块中遇到`return`语句时，`finally`语句块将在方法返回之前被执行。在以下 4 种特殊情况下，`finally`块不会被执行：
  - 在`finally`语句块中发生了异常
  - 在前面的代码中用了`System.exit()`退出程序
  - 程序所在的线程死亡
  - 关闭`CPU`

### 异常处理语句的语法规则

- 必须在`try`之后添加`catch`或`finally`块。`try`块后可同时接`catch`和`finally`块，但至少有一个块。
- 必须遵循块顺序：若代码同时使用`catch`和`finally`块，则必须将`catch`块放在`try`块之后。
- `catch`块与相应的异常类的类型相关。
- 一个`try`块可能有多个`catch`块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或其子类的实例，就执行这个`catch`代码块，不会再执行其他的`catch`代码块。
- 可嵌套`try-catch-finally`结构。
- 在`try-catch-finally`结构中，可重新抛出异常。
- 除了下列情况，总将执行`finally`做为结束：
  - JVM 过早终止（调用 System.exit(int)）；
  - 在`finally`块中抛出一个未处理的异常；
  - 计算机断电、失火、或遭遇病毒攻击。

## 异常抛出

任何Java代码都可以抛出异常，如：自己编写的代码、来自Java开发环境包中代码，或者Java运行时系统。无论是谁，都可以通过Java的`throw`语句抛出异常。从方法中抛出的任何异常都必须使用`throws`子句。

### throws抛出异常

如果一个方法可能会出现异常，但没有能力处理这种异常，可以在方法声明处用`throws`子句来声明抛出异常。`throws`语句用在方法定义时声明该方法要抛出的异常类型，如果抛出的是`Exception`异常类型，则该方法被声明为抛出所有的异常。多个异常可使用逗号分割。`throws`语句的语法格式为：

```java
methodname throws Exception1, Exception2, ... , ExceptionN {

}
```

方法名后的`throws Exception1, Exception2, ... , ExceptionN`为声明要抛出的异常列表。当方法抛出异常列表的异常时，方法将不对这些类型及其子类类型的异常作处理，而抛向调用该方法的方法，由他去处理。使用`throws`关键字将异常抛给调用者后，如果调用者不想处理该异常，可以继续向上抛出，但最终要有能够处理该异常的调用者。

throws抛出异常的规则：

- 如果是非检查异常（`unchecked exception`），即`Error`、`RuntimeException`或它们的子类，那么可以不使用`throws`关键字来声明要抛出的异常，编译仍能顺利通过，但在运行时会被系统抛出。
- 必须声明方法可抛出的任何检查异常（`checked exception`）。即如果一个方法可能出现受检查异常，要么用`try-catch`语句捕获，要么用`throws`子句声明将它抛出，否则会导致编译错误。
- 仅当抛出了异常，该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出，而不是囫囵吞枣。
- 调用方法必须遵循任何检查异常的处理和声明规则。若覆盖一个方法，则不能声明与覆盖方法不同的异常。声明的任何异常必须是被覆盖方法所声明异常的同类或子类。

### 使用throw抛出异常

`throw`总是出现在函数体中，用来抛出一个`Throwable`类型的异常。程序会在`throw`语句后立即终止，它后面的语句执行不到，然后在包含它的所有`try`块中（可能在上层调用函数中）从里向外寻找含有与其匹配的`catch`子句的`try`块。异常是异常类的实例对象，我们可以创建异常类的实例对象通过`throw`语句抛出。该语句的语法格式为：

```java
throw new ExceptionName();
```

> **注**：如果抛出了检查异常，则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。

### 异常链

在设计模式中有一个设计模式叫做**责任链模式**，该模式是将多个对象链接成一条链，客户端的请求沿着这条链传递直到被接收、处理。同样Java异常机制也提供了这样一条链：**异常链**。

我们知道每遇到一个异常信息，我们都需要进行`try-catch-finally`,一个还好，如果出现多个异常呢？分类处理肯定会比较麻烦，那就一个`Exception`解决所有的异常吧。这样确实是可以，但是这样处理势必会导致后面的维护难度增加。最好的办法就是将这些异常信息封装，然后捕获我们的封装类即可。

我们有两种方式处理异常，一是`throws`抛出交给上级处理，二是`try-catch`做具体处理。但是这个与上面有什么关联呢？`try-catch`的`catch`块我们可以不需要做任何处理，仅仅只用`throw`这个关键字将我们封装异常信息主动抛出来。然后在通过关键字`throws`继续抛出该方法异常。它的上层也可以做这样的处理，以此类推就会产生一条由异常构成的异常链。

**通过使用异常链，我们可以提高代码的可理解性、系统的可维护性和友好性**。

同理，我们有时候在捕获一个异常后抛出另一个异常信息，并且希望将原始的异常信息也保持起来，这个时候也需要使用异常链。

在异常链的使用中，`throw`抛出的是一个新的异常信息，这样势必会导致原有的异常信息丢失，如何保持？在`Throwable`及其子类中的构造器中都可以接受一个`cause`参数，该参数保存了原有的异常信息，通过`getCause()`就可以获取该原始异常信息。使用方式如下：

```java
public class Test {

    public void f() throws MyException{
         try {
             FileReader reader = new FileReader("test.txt");
             Scanner in = new Scanner(reader);
             System.out.println(in.next());
        } catch (FileNotFoundException e) {
            //e 保存异常信息
            throw new MyException("文件没有找到--01", e);
        }
    }

    public void g() throws MyException{
        try {
            f();
        } catch (MyException e) {
            //e 保存异常信息
            throw new MyException("文件没有找到--02", e);
        }
    }

    public static void main(String[] args) {
        Test t = new Test();
        try {
            t.g();
        } catch (MyException e) {
            e.printStackTrace();
        }
    }
}
```

如果在程序中,去掉`e`，也就是：`throw new MyException(“文件没有找到–02″);`那么异常信息就保存不了。

## 最佳实践

- 尽可能的减小`try`块。
- 充分使用`finally`块，保证所有资源都被正确释放；如果使用Java7及以后的版本，那么更推荐使用`try-with-resource`语法。
- `catch`语句应当尽量指定具体的异常类型，而不应该指定涵盖范围太广的`Exception`类。 不要一个`Exception`试图处理所有可能出现的异常。
- 不要忽略异常。既然捕获了异常，就要对它进行适当的处理。不要捕获异常之后又把它丢弃，不予理睬。
- 在异常处理模块中提供适量的错误原因信息，组织错误信息使其易于理解和阅读。
- 不要在`finally`块中处理返回值。
- 不要在构造函数中抛出异常。
- 为了给调用者提供尽可能多的信息，从而可以更好地避免/处理异常。对异常进行Javadoc文档说明，并且描述抛出异常的场景。
- 不要捕获`Throwable`。`Throwable`是所有异常和错误的父类。如果`catch`了`throwable`，那么不仅仅会捕获所有`Exception`，还会捕获`Error`。而`Error`是表明无法恢复的JVM错误。因此除非绝对肯定能够处理或者被要求处理`Error`，不要捕获`Throwable`。
- 包装异常时要包含原始的异常。包装异常时，一定要把原始的异常设置为`cause`(`Exception`有构造方法可以传入`cause`)。否则，丢失了原始的异常信息会让错误的分析变得困难。